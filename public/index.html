<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
    <title>Jellyfisher</title>
  <script type="text/javascript" src="js/phaser_2_0_3.min.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript">

var game = new Phaser.Game(800, 600, Phaser.AUTO, '', { preload: preload, create: create, update: update });


function preload() {
    game.load.image('water', 'images/water_big.png');
    game.load.image('ground', 'images/ground.png');
    game.load.image('waves', 'images/waves.png');
    game.load.image('sky', 'images/sky_big.png');
    game.load.spritesheet('jellysmall', 'images/jellyfish_small1.png', 8, 9);
    game.load.spritesheet('jellymed', 'images/jellyfish_medium1.png', 10, 12);
    game.load.spritesheet('jellybig', 'images/jellyfish_big1.png', 13, 16);
    game.load.spritesheet('puffers', 'images/puffer1.png', 17, 14);
    game.load.spritesheet('anglers', 'images/angler1.png', 17, 16);
    game.load.spritesheet('stingrays', 'images/stingray1.png', 17, 6);
    game.load.spritesheet('dude', 'images/octopus2.png', 16, 13);
}

var player;
var platforms;
var cursors;
var bgtile;
var skytile;
var groundtile;

var puffers;

var score = 0;
var scoreText;
var wasDown = null;

var xBoundLeft = 0;
var xBoundRight = 800;

var nextGroundX;

var emitter;

/*

* indicates mandatory

specs: {
    *spritesheet: 'some sheet definition', //may also be a function
    onPlayerApproach: function(member){ stuff to do to the member },
    onPlayerAway: function(member){ stuff to do to the member },
    onAnimationSetup: function(member){ stuff around animations and initial visual state },
    prey: 'label of prey if any',
    *speed: 125, //pixels per second i suppose? only required if there are prey
    label: 'some identifier', //defaults to spritesheet which must not be a function if so
    count: 10, //defaults to 2
    spawnModifier: 2 //defaults to 1
}
*/
var speciesManager = (function(){
    var allSpecies = [];

    var findSpeciesByLabel = function(label){
        for(var i=0; i<allSpecies.length; i++){
            if (allSpecies[i].label == label) {
                return(allSpecies[i]);
            }
        }
    }

    var bounceAbout = function(member){
        if(member.body.velocity.y > 0 && member.y > 400){
            member.body.velocity.y = -150 - 50*Math.random();
            if(Math.random() >= 0.5){
                member.body.velocity.x = -100;
            } else {
                member.body.velocity.x = -40;
            }
        }
    }

    return ({
        createSpecies: function(specs) {
            var lastSpawnX = xBoundRight;
            var nextSpawnXDelta = 120;
            var species;

            var correctSpawn = function(){
                if(nextSpawnXDelta > 2400) {
                    nextSpawnXDelta = 2400;
                } else if(nextSpawnXDelta < 50) {
                    nextSpawnXDelta = 50;
                }
            }

            var applySpawnModifier = function(modifier){
                nextSpawnXDelta+= modifier;
                correctSpawn();
            }

            var applySpawnMultiplier = function(multiplier){
                nextSpawnXDelta*= multiplier;
                correctSpawn();
            }

            var circulateBonus = function(){
                applySpawnModifier(-20);
            }

            var eatPreyBonus = function(){
                applySpawnMultiplier(0.5);
            }

            var killedPenalty = function(){
                applySpawnMultiplier(1.2);
            }

            var destroyPrey = function(_, prey) {
                prey.kill();
                eatPreyBonus();
            }

            var pursuePrey = function(predator, preys, speed) {
                game.physics.arcade.overlap(predator, preys, destroyPrey, null, this);
                var target = findNearest(predator,preys,function(prey) { return(prey.x < predator.x) });
                if (target) {
                    game.physics.arcade.moveToObject(predator, target, speed);
                } else {
                    predator.body.velocity.x = 0 - speed;
                    predator.body.velocity.y = 0;
                }
            }

            var createMember = function(x,y){
                var spritesheet;

                if(typeof(species.spritesheet) == "function"){
                    spritesheet = species.spritesheet();
                } else {
                    spritesheet = species.spritesheet;
                }
                member = species.group.create(x, y, spritesheet);
                member.scale.set(3);
                member.smoothed = false;
                member.events.onKilled.add(function(m){
                    killedPenalty();

                    emitter = game.add.emitter(m.x,m.y,50);
                    emitter.makeParticles(spritesheet);
                    emitter.minRotation = 0;
                    emitter.maxRotation = 0;
                    emitter.minParticleSpeed = new Phaser.Point(160,160);
                    emitter.maxParticleSpeed = new Phaser.Point(-160,-160);

                    //hack for scale bug workaround
                    emitter.setScale(3, 3.0001, 3, 3.0001, 200);
                    //emitter.smoothed = false;

                    emitter.setAlpha(0.8, 0, 600, Phaser.Easing.Bounce.Out);
                    emitter.gravity = 300;

                    emitter.start(true, 400, null, 16);
                }, this);
                species.onAnimationSetup(member, spritesheet);

            }

            species = {
                spritesheet: specs.spritesheet,
                onPlayerApproach: specs.onPlayerApproach || function(){},
                onPlayerAway: specs.onPlayerAway || function(){},
                onAnimationSetup: specs.onAnimationSetup || function(){},
                group: game.add.group(),
                label: specs.label || specs.spritesheet,
                prey: specs.prey,
                speed: specs.speed,
                count: specs.count || 4,
                spawnModifier: specs.spawnModifier || 1,
                reactToPlayer: function(member){
                    if(findRectilinearDistance(player,member) < 200) {
                        species.onPlayerApproach(member);
                    } else {
                        species.onPlayerAway(member);
                    }
                },
                spawnIfDue: function(){
                    var nextSpawnX = lastSpawnX+nextSpawnXDelta/species.spawnModifier;
                    var y;
                    if (nextSpawnX < xBoundRight) {
                        console.log(species.label+" last: "+lastSpawnX+" current: "+xBoundRight+" diff: "+nextSpawnXDelta);
                        lastSpawnX = xBoundRight;
                        y = game.world.height - 100 - 400*Math.random();

                        var dead = species.group.getFirstDead();
                        if(dead) {
                            dead.reset(lastSpawnX,y);
                            dead.frame = 0;
                        } else {
                            createMember(lastSpawnX,y);
                        }
                    }
                },
                update: function(){
                    var prey = findSpeciesByLabel(species.prey);

                    species.spawnIfDue();

                    species.group.forEachAlive(function(member){
                        if(member.x < xBoundLeft-50) {
                            member.kill();
                            circulateBonus();
                        } else {
                            species.reactToPlayer(member);

                            if(prey){
                                pursuePrey(member, prey.group, species.speed);
                            } else {
                                bounceAbout(member);
                            }
                        }
                    });
                }
            }
            allSpecies.push(species);
            species.group.enableBody = true;
            var member;
            for (var i = 0; i < species.count; i++) {
                createMember(xBoundRight-100*i-50, game.world.height - 100 - 400*Math.random());
            }
            return (species.group);
        },
        updateAllSpecies: function() {
            for(var i = 0; i < allSpecies.length; i++) {
                allSpecies[i].update();
            }
        }
    })
})();

function create() {

    //  We're going to be using physics, so enable the Arcade Physics system
    game.physics.startSystem(Phaser.Physics.ARCADE);

    game.world.setBounds(0,0, 1600, 600);

    //  A simple background for our game
    bgtile = game.add.tileSprite(0, 0, 900, 600, 'water');
    bgtile.autoScroll(-120,0);

    skytile = game.add.tileSprite(0, 0, 900, 54, 'sky');

    wavetile = game.add.tileSprite(0,54,900,6, 'waves');
    wavetile.autoScroll(-150,0);

    //  The platforms group contains the ground and the 2 ledges we can jump on
    platforms = game.add.group();

    //  We will enable physics for any object that is created in this group
    platforms.enableBody = true;

    // Here we create the grounds.
    var ground;
    for (var i = 0; i < 15; i++) {
        ground = platforms.create(i*60, game.world.height - 60, 'ground');

        //  Scale it to fit the width of the game (the original sprite is 400x32 in size)
        ground.scale.setTo(3);
        ground.smoothed = false;

        //  This stops it from falling away when you jump on it
        ground.body.immovable = true;
        nextGroundX = (i+1)*60;
    }

    // The player and its settings
    player = game.add.sprite(32, game.world.height - 150, 'dude');
    player.scale.set(3);
    player.smoothed = false;

    //  We need to enable physics on the player
    game.physics.arcade.enable(player);

    //  Player physics properties. Give the little guy a slight bounce.
    player.body.bounce.y = 0.2;
    player.body.gravity.y = 500;
    player.body.collideWorldBounds = true;

    //  Our two animations, walking left and right.
    player.animations.add('right', [0, 1, 0, 2], 10, true);
    var mad = player.animations.add('mad', [3,4,5,6,7,8,9,10], 20, false);
    mad.onComplete.add(function(){isMad = false;},this);
    player.frame = 0;

    puffers = speciesManager.createSpecies({
        spritesheet: 'puffers',
        count: 4,
        speed: 100,
        onPlayerApproach: function(m){
            m.frame = 1;
        },
        onPlayerAway: function(m){
            m.frame = 0;
        },
        prey: 'jellies',
    });

    speciesManager.createSpecies({
        spritesheet: 'anglers',
        count: 1,
        speed: 115,
        onAnimationSetup: function(m){
            m.animations.add('cruising', [0,1], 4, true);
            m.animations.add('scared', [2,3], 4, true);
            m.animations.play('cruising');
        },
        onPlayerApproach: function(m){
            m.play('scared');
        },
        onPlayerAway: function(m){
            m.play('cruising');
        },
        prey: 'puffers'
    });

    speciesManager.createSpecies({
        spritesheet: 'stingrays',
        count: 1,
        speed: 140,
        spawnModifier: 0.5,
        onAnimationSetup: function(m){
            m.animations.add('cruising', [0,1,0,2], 8, true);
            m.animations.play('cruising');
        },
        prey: 'anglers'
    });

    speciesManager.createSpecies({
        label: 'jellies',
        count: 6,
        spawnModifier: 10,
        spritesheet: function(){
            var picker = Math.random()*3;
            if (picker < 1) {
                return('jellysmall');
            } else if(picker < 2) {
                return('jellymed');
            } else {
                return('jellybig');
            }
        },
        onAnimationSetup: function(m,spritesheet){
            if(spritesheet == 'jellysmall') {
                m.animations.add(   'swim', [0, 1, 2], 10, true);
            } else {
                m.animations.add('swim', [0, 1, 2, 3, 4], 10, true);
            }

            m.body.gravity.y = 150;
        },
        onPlayerApproach: function(m){
            game.physics.arcade.overlap(player, m, collectJelly, null, this);
        }
    })

    //  The score
    scoreText = game.add.text(16, 16, 'score: 0', { fontSize: '32px', fill: '#000' });
    scoreText.fixedToCamera = true;

    //  Our controls.
    cursors = game.input.keyboard.createCursorKeys();
}

var isMad = false;

function update() {
    game.camera.focusOn(player);
    updatePlatforms();
    speciesManager.updateAllSpecies();

    if (xBoundLeft < player.x-400) { xBoundLeft = player.x-400; }
    if (xBoundRight < player.x+400) { xBoundRight = player.x+400; }

    game.world.setBounds(xBoundLeft,0, xBoundRight+1600, 600);
    bgtile.width = xBoundRight;
    skytile.width = xBoundRight;
    wavetile.width = xBoundRight;

    game.physics.arcade.collide(player, platforms);

    if (player.body.velocity.x > 0) {
        player.body.velocity.x-= 3;
    }
    if (player.body.velocity.y > 200) {
        player.body.velocity.y = 200;
    }

    if (game.input.activePointer.isDown) {
        player.body.velocity.x = 220;
        player.body.velocity.y = -250;

        player.animations.play('right');
        if(!wasDown) {
            wasDown = game.time.now;
        }
    } else {
        if(wasDown+500 > game.time.now) {
            wasDown = null;
            var killed = false;
            game.physics.arcade.overlap(player, puffers, function(_,puffer){
                killed = true;
                puffer.kill();
            }, null, this);
            if(killed){
                isMad = true;
                player.animations.play('mad');
            }
        } else {
            wasDown = null;
            if(!isMad) {
                player.frame = 0;
                player.animations.stop();
            }
        }
    }
}

function updatePlatforms() {
    platforms.forEach(function(platform){
        if (platform.x < xBoundLeft-60){
            platform.kill();
            platform.reset(nextGroundX, game.world.height - 60);
            nextGroundX+=60;
        }
    });
}

function findRectilinearDistance(a,b) {
  return (Math.abs(a.x-b.x) + Math.abs(a.y-b.y));
}

function findNearest(reference,group,filter) {
  var min;
  var currDist;
  var nearest;

  group.forEachAlive(function(member){
    if(!filter || filter(member)) {
        currDist = findRectilinearDistance(member,reference);

        if(!min || currDist < min) {
          min = currDist;
          nearest = member;
        }
    }

  });

  return nearest;
}

function collectJelly (player, jelly) {

    // Removes the jelly from the screen
    jelly.kill();

    //  Add and update the score
    score += 10;
    scoreText.text = 'Score: ' + score;

}



</script>

</body>
</html>
