<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
    <title>Jellyfisher</title>
  <script type="text/javascript" src="js/phaser.min.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript">

var game = new Phaser.Game(800, 600, Phaser.AUTO, '', { preload: preload, create: create, update: update });

function preload() {

    game.load.image('water', 'images/bgtile.png');
    game.load.image('ground', 'images/ground.png');
    game.load.image('sky', 'images/sky_tile.png');
    game.load.spritesheet('jellysmall', 'images/jellyfish_small.png', 7, 9);
    game.load.spritesheet('jellymed', 'images/jellyfish_medium.png', 9, 12);
    game.load.spritesheet('jellybig', 'images/jellyfish_big.png', 12, 16);
    game.load.spritesheet('puffer', 'images/puffer.png', 16, 14);
    game.load.spritesheet('dude', 'images/octopus.png', 15, 13);

}

var player;
var platforms;
var cursors;
var bgtile;
var skytile;
var groundtile;
var puffers;

var jellies;
var score = 0;
var scoreText;
var wasDown = null;

var xBoundLeft = 0;
var xBoundRight = 800;

var nextGroundX;
var nextJellyX = 900;
var nextPufferX = xBoundRight+200;

function create() {

    //  We're going to be using physics, so enable the Arcade Physics system
    game.physics.startSystem(Phaser.Physics.ARCADE);

    game.world.setBounds(0,0, 1600, 600);

    //  A simple background for our game
    bgtile = game.add.tileSprite(0, 0, 600, 200, 'water'); //divided by 3
    bgtile.scale.setTo(3);

    skytile = game.add.tileSprite(0, 0, 600, 20, 'sky'); //divided by 3
    skytile.scale.setTo(3);

    // groundtile = game.add.tileSprite(0, 540, 600, 20, 'ground'); //divided by 3
    // groundtile.scale.setTo(3);
    // game.physics.enable(groundtile, Phaser.Physics.ARCADE);
    // groundtile.body.immovable = true;


    //  The platforms group contains the ground and the 2 ledges we can jump on
    platforms = game.add.group();

    //  We will enable physics for any object that is created in this group
    platforms.enableBody = true;

    // Here we create the grounds.
    var ground;
    for (var i = 0; i < 15; i++) {
        ground = platforms.create(i*60, game.world.height - 60, 'ground');

        //  Scale it to fit the width of the game (the original sprite is 400x32 in size)
        ground.scale.setTo(3);

        //  This stops it from falling away when you jump on it
        ground.body.immovable = true;
        nextGroundX = (i+1)*60;
    }

    // The player and its settings
    player = game.add.sprite(32, game.world.height - 150, 'dude');
    player.scale.set(3);
    player.smoothed = false;

    //  We need to enable physics on the player
    game.physics.arcade.enable(player);

    //  Player physics properties. Give the little guy a slight bounce.
    player.body.bounce.y = 0.2;
    player.body.gravity.y = 500;
    player.body.collideWorldBounds = true;

    //  Our two animations, walking left and right.
    player.animations.add('right', [0, 1, 2], 10, true);
    var mad = player.animations.add('mad', [3,4,3,4], 8, false);
    mad.onComplete.add(function(){isMad = false;},this);
    player.frame = 0;

    puffers = game.add.group();
    puffers.enableBody = true;
    var puffer = puffers.create(xBoundRight-50, game.world.height - 200, 'puffer');
    puffer.scale.set(3);
    puffer.smoothed = false;

    puffer = puffers.create(xBoundRight-200, game.world.height - 200, 'puffer');
    puffer.scale.set(3);
    puffer.smoothed = false;

    //  Finally some jellies to collect
    jellies = game.add.group();

    //  We will enable physics for any jelly that is created in this group
    jellies.enableBody = true;

    //  Here we'll create 12 of them evenly spaced apart
    for (var i = 0; i < 12; i++)
    {
        var jelly;
        if (i%3 == 0) {
            jelly = jellies.create(i * 70, 0, 'jellysmall');
            jelly.animations.add('swim', [0, 1, 2], 10, true);
        } else if (i%3 == 1) {
            jelly = jellies.create(i * 70, 0, 'jellymed');
            jelly.animations.add('swim', [0, 1, 2, 3, 4], 10, true);
        } else {
            jelly = jellies.create(i * 70, 0, 'jellybig');
            jelly.animations.add('swim', [0, 1, 2, 3, 4], 10, true);
        }

        jelly.scale.set(3);
        jelly.smoothed = false;
        jelly.animations.play('swim');

        //  Let gravity do its thing
        jelly.body.gravity.y = 300;

        //  This just gives each jelly a slightly random bounce value
        jelly.body.bounce.y = 0.7 + Math.random() * 0.2;
    }

    //  The score
    scoreText = game.add.text(16, 16, 'score: 0', { fontSize: '32px', fill: '#000' });
    scoreText.fixedToCamera = true;

    //  Our controls.
    cursors = game.input.keyboard.createCursorKeys();

}

var isMad = false;

function update() {
    game.camera.focusOn(player);
    updatePlatforms();
    updateJellyfish();
    updatePuffers();

    if (xBoundLeft < player.x-400) { xBoundLeft = player.x-400; }
    if (xBoundRight < player.x+400) { xBoundRight = player.x+400; }

    game.world.setBounds(xBoundLeft,0, xBoundRight+1600, 600);
    bgtile.width = xBoundRight;
    skytile.width = xBoundRight;

    //  Collide the player and the jellies with the platforms
    game.physics.arcade.collide(player, platforms);
    game.physics.arcade.collide(jellies, platforms);

    //  Checks to see if the player overlaps with any of the jellies, if he does call the collectStar function
    game.physics.arcade.overlap(player, jellies, collectStar, null, this);

    if (player.body.velocity.x > 0) {
        player.body.velocity.x-= 1;
    }

    if (game.input.activePointer.isDown) {
        player.body.velocity.x = 150;
        player.body.velocity.y = -250;

        player.animations.play('right');
        if(!wasDown) {
            wasDown = game.time.now;
        }
    } else {
        if(wasDown+500 > game.time.now) {
            console.log('quick!');
            wasDown = null;
            var nearestEnemy = findNearest(player,puffers);
            var dist = findRectilinearDistance(player,nearestEnemy);
            console.log(dist);
            if(nearestEnemy && dist < 80) {
                nearestEnemy.kill();
                isMad = true;
                player.animations.play('mad');
            }
        } else {
            wasDown = null;
            if(!isMad) {
                player.frame = 0;
                player.animations.stop();
            }
        }
    }
}

function updatePuffers() {
    puffers.forEachAlive(function(puffer){
        if(puffer.x < xBoundLeft-50) {
            console.log('killin');
            puffer.kill();
        }
    });
    if (nextPufferX < xBoundRight+50) {
        var deadPuffer = puffers.getFirstDead();
        if(deadPuffer) {
            console.log('new!');
            deadPuffer.reset(xBoundRight-50, game.world.height - 200);
            deadPuffer.frame = 0;
            nextPufferX = xBoundRight+200;
        }
    }
    puffers.forEachAlive(function(puffer){
        if(findRectilinearDistance(player,puffer) < 200) {
            puffer.frame = 1;
            puffer.body.velocity.x = 0;
            puffer.body.velocity.y = 0;
        } else {
            game.physics.arcade.overlap(puffer, jellies, destroyJelly, null, this);
            puffer.frame = 0;
            var target = findNearest(puffer,jellies);
            game.physics.arcade.moveToObject(puffer, target, 100);
        }
    });
}

function updateJellyfish() {
    var jelly;
    jellies.forEachAlive(function(jelly){
        if(jelly.x < xBoundLeft-50) {
            jelly.kill();
        }
    });
    if(nextJellyX < xBoundRight+100) {
        jelly = jellies.getFirstDead();
        if(jelly){
            jelly.reset(xBoundRight+50,0);
            nextJellyX = xBoundRight+200;
        }
    }

}

function updatePlatforms() {
    platforms.forEach(function(platform){
        if (platform.x < xBoundLeft-60){
            console.log('new!');
            platform.kill();
            platform.reset(nextGroundX, game.world.height - 60);
            nextGroundX+=60;
        }
    });
}

function findRectilinearDistance(a,b) {
  return (Math.abs(a.x-b.x) + Math.abs(a.y-b.y));
}

function findNearest(reference,group) {
  var min;
  var currDist;
  var nearest;

  group.forEachAlive(function(member){
    currDist = findRectilinearDistance(member,reference);

    if(!min || currDist < min) {
      min = currDist;
      nearest = member;
    }
  });

  return nearest;
}

function collectStar (player, jelly) {

    // Removes the jelly from the screen
    jelly.kill();

    //  Add and update the score
    score += 10;
    scoreText.text = 'Score: ' + score;

}

function destroyJelly (_, jelly) {
    jelly.kill();
}

</script>

</body>
</html>
